
Различные символы стрелок: ← ↑ → ↓ △ ▽ ◁ ▷

Различные символы для маркированных списков:
▣ ◼ □ ● ○ ▶ ▷ ◆ ◇ 🔒

Символ муравья: 🐜 (для маркировки дефектов)

Французские кавычки: «ёлочки» [ «» ] 
(для кавычек в тексте)

Это нужно знать-понимать: (←_←) | (→_→)

Для всяческих сносок в тексте маленькие 
циферки: ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽⁾
_________________________________________________________________________________________________________________________________________________________________

『--- База данных ---』

^- База данных (БД) — это организованная структура для хранения, 
изменения и обработки взаимосвязанной информации. Обычно базы данных 
используют для взаимодействия с большими объёмами данных. Практически 
ни одна большая компания (от интернет-магазинов до банков) сейчас не 
обходится без использования баз данных.

1. Реляционные базы данных. 
В них данные хранятся в виде связанных таблиц. 
Связанные таблицы — это таблицы, в которых мы явно 
видим зависимость данных одной таблицы от другой. 
Например, в одной мы храним данные о сотрудниках, 
а во второй — их зарплату.

2. Нереляционные базы данных. 
В них данные хранятся иначе, например, 
в формате ключ-значение или в виде дерева.
---------------------------------------------------------------------------------------------------------

『--- Транзакция ---』

^- Транзакция — это ряд действий, выполняемых подряд, 
которые должны быть обработаны полностью, или в случае 
сбоя БД быть восстановлены до состояния, пока транзакция 
не началась.

Схематично транзакцию для решения 
нашей проблемы можно представить так:

НАЧАЛО ТРАНЗАКЦИИ;
ИЗМЕНЯЕМ ДАННЫЕ В ПЕРВОЙ ТАБЛИЦЕ;
ИЗМЕНЯЕМ ДАННЫЕ ВО ВТОРОЙ ТАБЛИЦЕ;
КОНЕЦ ТРАНЗАКЦИИ;

Хорошим примером транзакции также будет являться такой пример: 
допустим у нас есть база данных с таблицей, в которой мы храним 
счёт каждого пользователя. Один пользователь передает средства 
второму пользователю.

Схематичное представление транзакции выглядит следующим образом:

НАЧАЛО ТРАНЗАКЦИИ;
СЧЁТ ПЕРВОГО ПОЛЬЗОВАТЕЛЯ = СЧЁТ ПЕРВОГО ПОЛЬЗОВАТЕЛЯ - СУММА СРЕДСТВ;
СЧЁТ ВТОРОГО ПОЛЬЗОВАТЕЛЯ = СЧЁТ ВТОРОГО ПОЛЬЗОВАТЕЛЯ + СУММА СРЕДСТВ;
КОНЕЦ ТРАНЗАКЦИИ;

Как видим из примера, если что-то произойдёт в момент переноса средств, 
то транзакция отменяется, а база вернется в первоначальное состояние до 
транзакции. Откатывает базу до первоначального состояния СУБД.
---------------------------------------------------------------------------------------------------------

『--- Система Управления Базами Данных ---』

^- Система Управления Базами Данных (СУБД, DBMS — DataBase Management System) — это 
комплекс программных средств, необходимых для создания структуры новой базы, её 
наполнения, редактирования содержимого и отображения информации.

Для работы с данными, хранящимися в БД, используется 
специальный язык — SQL, который мы и будем изучать 
в данном курсе.

СУБД бывают разные, и языки для них тоже отличаются, являясь диалектами SQL. 
Наиболее распространенными СУБД являются: MySQL, PostgreSQL, Oracle, Microsoft SQL Server.
(У меня как раз стоит именно - Microsoft SQL Server и когда я был в Engy был тоже он (MSSQL))
---------------------------------------------------------------------------------------------------------

『--- SQL ---』

^- Для взаимодействия с базами данных через СУБД часто используется язык 
структурированных запросов SQL (аббр. от англ. Structured Query Language). 
Он применяется для создания, модификации и управления данными.

Вот схема простого SQL-запроса:

SELECT column_names
FROM table_name
WHERE conditions

С помощью этого запроса можно 
получить данные из БД. Разберем запрос:

● SELECT отвечает за то, какие колонки будут выбираться из данных.

● FROM — за то, из какой таблицы эти данные.

● WHERE — за фильтрацию строк в данных.

Переводим запрос на русский язык:

ВЫБЕРИ (SELECT) колонки column_names ИЗ (FROM) ТАБЛИЦЫ table_name, 
ДЛЯ СТРОК КОТОРЫХ ВЫПОЛНЕНЫ УСЛОВИЯ (WHERE) conditions.

При использовании SQL очень важно соблюдать порядок ключевых слов.

Обязательные ключевые слова при выполнении запроса — только SELECT 
(если данные выбираются не из таблицы) и SELECT + FROM, если из таблицы). 
Остальные можно не включать в запрос.

Нужно ли ставить точку с запятой (;) в конце запроса? 
Это зависит от конкретной СУБД. Например, в большинстве 
современных СУБД делать это не обязательно.

SQL не чувствителен к регистру, поэтому ключевые слова можно 
писать в любом регистре, например, SELECT или SeLeCt.
---------------------------------------------------------------------------------------------------------

『--- Redis ---』

^- Redis (Remote Dictionary Server) — это нереляционная структура данных в памяти, 
используемая в качестве базы данных. Работает с данными ключ-значение. Разработана 
для максимальной скорости set- и get-запросов. Позволяет нам хранить данные в 
высокоуровневых структурах данных, таких как строки, хэши, списки, наборы.
---------------------------------------------------------------------------------------------------------

『--- Реляционная база данных ---』

^- Реляционная база данных — это набор данных с предопределенными связями между ними. 
Эти данные представлены в виде таблиц, состоящих из столбцов и строк. В каждом столбце 
таблицы хранится определенный тип данных, в каждой ячейке — значение. Каждая строка в 
такой таблице предоставляет набор значений, относящихся к одному объекту.
---------------------------------------------------------------------------------------------------------

🔒🔒🔒
MySQL (server)
Мои учётные данные 
как администратора БД:

Password:
R}*^s1sD1t6M 

Username:
Demetriusz

🐜 ВАЖНО:
Для того чтобы скопированный из блокнота пароль 
вставить в консоль MySQL (текстовый интерфейс) 
с помощью правой кнопки мыши, то нужно вначале
 
этого процесса ОБЯЗАТЕЛЬНО поменять раскладку 
на клавиатуре на английский язык!!!
---------------------------------------------------------------------------------------------------------

Первые команды MySQL:

◆ SHOW DATABASES; — Покажи все базы данных (БД) на сервере 

◆ USE information_schema; — используй указанную здесь БД

◆ SHOW TABLES; — Покажи все таблицы в какой-либо БД

◆ SHOW TABLES LIKE "Datasheet%"; — Покажи всё, 
что похоже на таблицы (для какой-либо из БД)

◆ CREATE DATABASE testdb; — создай тестовую БД
---------------------------------------------------------------------------------------------------------

Создаём нашу первую БД:

◼ Создаем нашу тестовую БД:

mysql> CREATE DATABASE testdb;

◼ Делаем нашу БД активной 
для дальнейшей работы с ней:

mysql> use testdb;

◼ Создаём нашу первую ТБ с 
помощью команды CREATE TABLE:

CREATE TABLE testtable (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT
);

^- здесь «testtable» это имя 
для нашей первой таблицы (ТБ)
---------------------------------------------------------------------------------------------------------

Необходимые пояснения:

● id — это поле, в котором мы храним уникальный идентификатор для каждой 
созданной строки в таблице (также, это название для нашего первого столбца);

● INT — говорит о том, что этот идентификатор — целое 
число (в программировании int целочисленный тип данных);

● AUTO_INCREMENT — автоматическое инкрементирование (наш id как целое 
число будет возрастать на +1 с каждым добавлением в ТБ новой строки);

● PRIMARY KEY — указывает, что это поле в нашей ТБ — первичный ключ;

● title — собственно название для нашего второго столбца;

● VARCHAR(255) — это значит, что данное поле состоит из символов не 
более 255 штук (это максимальное количество символов в одной ячейке ТБ);

● NOT NULL — это поле должно быть обязательно заполнено 
при вставке в таблицу, иначе никакой запрос не пройдёт;

● description — название для нашего третьего столбца;

● столбец TEXT в большинстве случаев может рассматриваться как столбец 
VARCHAR неограниченного размера (по сути это строка неограниченного размера).

^- И тогда получается, что VARCHAR(255) - это по сути строка ограниченного 
размера (и длина этой строки ограничена количеством символов до 255 шт.).
---------------------------------------------------------------------------------------------------------

▶ И теперь мы заносим в нашу новую таблицу 
тестовые данные с помощью команды insert:

mysql> insert testtable(title, description) VALUES('test1', 'test2');

mysql> insert testtable(title, description) VALUES('test1111', 'test22222');

▶ Просматриваем занесённые нами данные:

mysql> select * from testtable;

▣ Вывод ТБ в консоль:
+----+----------+-------------+
| id | title    | description |
+----+----------+-------------+
|  1 | test1    | test2       |
|  2 | test1111 | test22222   |
+----+----------+-------------+
---------------------------------------------------------------------------------------------------------

『--- Уникальные и первичные ограничения ---』

^- Ограничение UNIQUE гарантирует, что все значения в столбце различаются. 
А уникальные и первичные ограничения предоставляют гарантию уникальности для 
столбца или набора столбцов. Ограничение первичного ключа автоматически имеет 
уникальное ограничение. Однако, можно иметь много уникальных ограничений для 
каждой таблицы, но только одно ограничение первичного ключа для какой-либо 
таблицы.
---------------------------------------------------------------------------------------------------------

◆ Пример использования ограничения UNIQUE:

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);
---------------------------------------------------------------------------------------------------------

● Также мы можем менять данные в таблице с помощью оператора UPDATE.

● Оператор UPDATE обновляет столбцы в соответствии 
с их новыми значениями в строках существующей таблицы. 

● В выражении SET указывается, какие именно столбцы следует 
модифицировать и какие величины должны быть в них установлены. 

● В выражении WHERE, если оно присутствует, 
задаётся, какие строки подлежат обновлению.
---------------------------------------------------------------------------------------------------------

▶ Пример использования оператора UPDATE:

mysql> UPDATE testtable SET title = "REALTEST" where id = 2;

▶ Просмотр изменений в нашей ТБ:

mysql> select * from testtable;

▣ Вывод ТБ в консоль:
+----+----------+-------------+
| id | title    | description |
+----+----------+-------------+
|  1 | test1    | test2       |
|  2 | REALTEST | test22222   |
+----+----------+-------------+
---------------------------------------------------------------------------------------------------------

Как мы узнали в предыдущем юните, таблица — это совокупность 
связанных данных, хранящихся в структурированном виде в БД. 
Она состоит из столбцов и строк.

В реляционных БД таблица — это набор элементов данных (значений), 
использующий модель вертикальных столбцов (имеющих уникальное имя) 
и горизонтальных строк.

Ячейка — место, где строка и столбец пересекаются. 
Таблица содержит определенное число столбцов, 
но может иметь любое количество строк.

Если в таблице каждая строка однозначно определяется 
одним или несколькими уникальными значениями, которые 
принимают её ячейки из определенного подмножества столбцов, 
то говорят, что у таблицы есть первичный ключ.
---------------------------------------------------------------------------------------------------------

『--- Первичный ключ ---』

^- Иными словами, первичный ключ — это подмножество столбцов, 
которое уникально идентифицирует строку. Часто в качестве первичного 
ключа берут просто ID объекта, например, ID пользователя или ID покупки.

В MySQL первичный ключ — это одно поле или несколько полей, 
которые определяют уникальность записи. Ячейки, являющиеся 
частью первичного ключа, не могут содержать значение NULL. 
Кстати, в каждой таблице может быть только один первичный 
ключ.
---------------------------------------------------------------------------------------------------------

Есть несколько способов создать первичный ключ.

1. Первый способ:

CREATE TABLE developers(
    ID INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    NAME VARCHAR(100) NOT NULL,
    SPECIALTY VARCHAR(100) NOT NULL,       
    SALARY INT NOT NULL
);

2. Второй способ:

CREATE TABLE developers(
    ID INT NOT NULL AUTO_INCREMENT,
    NAME VARCHAR(100) NOT NULL,
    SPECIALTY VARCHAR(100) NOT NULL,       
    SALARY INT NOT NULL,
    PRIMARY KEY (ID)
);

В обоих случаях первичным ключом будет являться поле ID.
---------------------------------------------------------------------------------------------------------

◆ Для того чтобы определить первичный ключ в уже существующей 
таблице, в MySQL мы должны применить следующую команду:

ALTER TABLE developers ADD PRIMARY KEY (ID);

◆ Для удаления первичного ключа 
используется следующая команда:

ALTER TABLE developers DROP PRIMARY KEY;

🐜 ВАЖНО:
Вышеозначенной командой нельзя будет удалить этот атрибут (PRIMARY KEY) 
если у столбца с первичным ключом есть ещё один атрибут (AUTO_INCREMENT), 
т. к. у таблицы может быть только один авто-инкрементирующий столбец, и он 
должен быть определён как первичный ключ (об этом говорит нам: ERROR 1075).
---------------------------------------------------------------------------------------------------------

🐜 ВАЖНО:
Если завести таблицу, где, к примеру, первый столбец с именем - ID (+ INT как тип данных) 
имеет атрибуты первичного ключа и не может равняться - NULL, но при этом у него не будет 
атрибута - AUTO_INCREMENT, то при использовании команды - INSERT (добавление значений 
в строки таблицы) в скобки после названия таблицы нужно будет добавить первым значением 
имя столбца - ID и дополнительно присвоить для него порядковый номер в значениях (VALUES).
А иначе мы получим ошибку, что поле "ID" не имеет значения по умолчанию (ERROR 1364: Field 
'ID' doesn't have a default value).

Примеры:

▷ Создаём таблицу:

CREATE TABLE earwigs(
    ID INT NOT NULL,
    genus VARCHAR(100) NOT NULL,
    size VARCHAR(100) NOT NULL,       
    limbs INT NOT NULL,
    PRIMARY KEY (ID)
);

▷ Пытаемся вставить новые записи 
в таблицу с помощью оператора INSERT:

INSERT earwigs(genus, size, limbs) VALUES('clumsy', 'large', 10);

INSERT earwigs(genus, size, limbs) VALUES('revolting', 'petty', 12);

▷ Получаем ошибку:

ERROR 1364 (HY000): Field 'ID' doesn't have a default value

▷ Меняем параметры для вставки 
новых записей в нашу таблицу:

INSERT earwigs(ID, genus, size, limbs) VALUES(1, 'clumsy', 'large', 10);

INSERT earwigs(ID, genus, size, limbs) VALUES(2, 'revolting', 'petty', 12);

INSERT earwigs(ID, genus, size, limbs) VALUES(3, 'filthy', 'average', 8);

▷ Просмотр таблицы:

SELECT * FROM earwigs;

▣ Вывод ТБ в консоль:
+----+-----------+---------+-------+
| ID | genus     | size    | limbs |
+----+-----------+---------+-------+
|  1 | clumsy    | large   |    10 |
|  2 | revolting | petty   |    12 |
|  3 | filthy    | average |     8 |
+----+-----------+---------+-------+
---------------------------------------------------------------------------------------------------------

🐜 ВАЖНО:
Для проверки, что у нашего поля - ID действительно 
имеется атрибут - PRIMARY KEY (первичный ключ)
можно вызвать следующую ошибку:

▷ Пытаемся вставить новую запись 
в таблицу с помощью оператора INSERT:

INSERT earwigs(ID, genus, size, limbs) VALUES(3, 'vile', 'small', 14);

^- Мы знаем, что в нашей таблице уже есть сущность с id = 3, 
но специально написали нашу команду так, чтобы вызвать ошибку.

▷ Получаем ошибку:

ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

^- Попытка дублирования записи для первичного ключа, 
а как мы уже знаем все записи для первичного ключа 
должны быть уникальными.
---------------------------------------------------------------------------------------------------------

🐜 ВАЖНО:
И ещё для дополнительной проверки (как же всё в MySQL 
функционирует) мы можем выполнить следующие шаги:

▷ Убираем у нашей таблицы (earwigs) первичный ключ (ID) и назло всему таки 
добавляем ту запись, которую не могли добавить из-за ошибки (ERROR 1062):

ALTER TABLE earwigs DROP PRIMARY KEY;

INSERT earwigs(ID, genus, size, limbs) VALUES(3, 'vile', 'small', 14);

▷ А теперь мы пытаемся вернуть 
первичный ключ (ID) нашей таблице: 

ALTER TABLE earwigs ADD PRIMARY KEY (ID);

▷ И мы снова получаем ту же ошибку:

ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

^- Попытка дублирования записи для первичного ключа.

▷ Смотрим, что у нас в таблице:

SELECT * FROM earwigs;

▣ Вывод ТБ в консоль:
+----+-----------+---------+-------+
| ID | genus     | size    | limbs |
+----+-----------+---------+-------+
|  1 | clumsy    | large   |    10 |
|  2 | revolting | petty   |    12 |
|  3 | filthy    | average |     8 |
|  3 | vile      | small   |    14 |
+----+-----------+---------+-------+

^- У нас две сущности ТБ с одинаковым ID,
а для первичного ключа это уже неприемлемо.

▷ И в этом случае мы меняем с помощью оператора UPDATE значение для 
ID c «3» на «4» у последней по порядку сущности в ТБ (недавно нами 
добавленной). И снова пытаемся вернуть первичный ключ (ID) нашей 
таблице (на этот раз уже успешно):

UPDATE earwigs SET ID = 4 WHERE limbs = 14;

ALTER TABLE earwigs ADD PRIMARY KEY (ID);

▷ Смотрим нашу таблицу:

SELECT * FROM earwigs;

▣ Вывод ТБ в консоль:
+----+-----------+---------+-------+
| ID | genus     | size    | limbs |
+----+-----------+---------+-------+
|  1 | clumsy    | large   |    10 |
|  2 | revolting | petty   |    12 |
|  3 | filthy    | average |     8 |
|  4 | vile      | small   |    14 |
+----+-----------+---------+-------+
---------------------------------------------------------------------------------------------------------

『--- Внешний ключ SQL ---』

^- Внешний ключ SQL — это ключ, используемый для объединения двух таблиц. 
Иногда его также называют ссылочным ключом. Внешний ключ — это столбец или 
набор столбцов, которые соответствуют первичному ключу в другой таблице.
---------------------------------------------------------------------------------------------------------

◼ Связь между таблицами можно задать через соответствие 
внешнего ключа в одной таблице к первичному ключу в другой.

◼ Создадим две таблицы и потом создадим внешний ключ.

1. Первая таблица:

CREATE TABLE CUSTOMERS(
    ID INT NOT NULL,
    NAME VARCHAR(20) NOT NULL,
    AGE INT NOT NULL,
    ADDRESS CHAR(25),
    SALARY DECIMAL(18, 2),       
    PRIMARY KEY(ID)
);

2. Вторая таблица:

CREATE TABLE ORDERS(
    ID INT NOT NULL,
    DATE DATETIME,
    CUSTOMER_ID INT references CUSTOMERS(ID),
    AMOUNT double,
    PRIMARY KEY(ID)
);

◼ Если таблица ORDERS уже создана и для неё еще не установлен 
внешний ключ, то можно воспользоваться командой добавления 
внешнего ключа через команду изменения таблицы.

Пример:

ALTER TABLE ORDERS ADD FOREIGN KEY(Customer_ID) REFERENCES CUSTOMERS(ID);
---------------------------------------------------------------------------------------------------------

Обычно в СУБД помимо атрибутов каждой сущности (строки) определяется также связь между сущностями. 
Например, утверждение «покупатели покупают продукты» указывает, что существует связь между сущностью 
«покупатели» и сущностью «продукты». Сущность «покупатели» и сущность «продукты» являются участниками 
связи.

Число участников определяет размерность связи. У большей части отношений — два участника, 
хотя на практике их может быть и больше, например, в утверждении «сотрудники продают товары 
покупателям» видна тройная связь.

При таких утверждениях становится ясно, что связи между сущностями могут быть различны.
---------------------------------------------------------------------------------------------------------

[*** Три типа связи ***]

Существует всего три типа связи:

● «ОДИН-К-ОДНОМУ» («ONE-TO-ONE»);

● «ОДИН-КО-МНОГИМ» («ONE-TO-MANY»);

● «МНОГИЕ-КО-МНОГИМ» («MANY-TO-MANY»).
---------------------------------------------------------------------------------------------------------

[*** Один к одному ***]

Связь «ОДИН-К-ОДНОМУ» встречается достаточно редко. 
И обычно появляется при ошибках проектирования. Самый 
простой пример такой связи — когда у нас в одной таблице 
находятся названия книг и оглавление, а во второй — названия 
книг и их текст.

Отношение «ОДИН-К-ОДНОМУ» похоже на отношение «ОДИН-КО-МНОГИМ» в том смысле, 
что оно связывает внешний ключ с уникальным ключом. Разница здесь лишь в том, 
что связываемый ключ должен быть уникальным (свойство UNIQUE) для поддержания 
отношения «ОДИН-К-ОДНОМУ», чтобы соединить не более одной зависимой строки с 
одной родительской строкой. (←_←)

Обычным является дублирование столбца (столбцов) первичного ключа в подчиненной таблице.
---------------------------------------------------------------------------------------------------------

□ Реализуем связь «ОДИН-К-ОДНОМУ» на практике.

◼ Создаем БД (мы уже знаем как) 
и выбираем её в качестве основной:

mysql> create database onetoone;

mysql> use onetoone;

□ Создаем первую табличку. Хорошим примером таблиц для такой связи будут 
таблицы «сотрудники» – «паспортные данные», т. к. тут доступ к таблице 
«сотрудники» должен быть у всех, а к таблице «паспортные данные» — не 
у всех.

□ Второй хороший пример — «сотрудники компании» – «автомобили компании», 
но это при условии, что на 1-ом автомобиле постоянно ездит 1-ин сотрудник. 
Рассмотрим второй пример на практике более детально.

◼ Создаем таблицу сотрудников компании:

CREATE TABLE employees(
    ID INT AUTO_INCREMENT PRIMARY KEY,
    NAME VARCHAR(80) NOT NULL,
    SURNAME VARCHAR(80) NOT NULL,
    PATRONYMIC VARCHAR(80),
    CITY VARCHAR(40),
    ADDRESS VARCHAR(150),
    NUMBER VARCHAR(13), 
    CAR_ID INT NOT NULL
);

□ Последнее поле CAR_ID сделаем внешним ключом после появления второй таблицы.
Обычно внешний ключ одной таблицы должен ссылаться на первичный ключ другой.

◼ А теперь мы добавим вторую таблицу 
с содержанием автомобилей сотрудников:

CREATE TABLE cars(
    CAR_ID INT AUTO_INCREMENT PRIMARY KEY,
    YEAR VARCHAR(4), 
    MODEL VARCHAR(20),
    MARK VARCHAR(20)
);

◼ Ещё мы на всякий случай сделаем поле 
CAR_ID в таблице employees уникальным:

mysql> ALTER TABLE employees MODIFY COLUMN CAR_ID INT NOT NULL UNIQUE;

◼ Теперь же самое время связать 
наши таблицы внешним ключом:

mysql> ALTER TABLE employees ADD FOREIGN KEY(CAR_ID) REFERENCES cars(CAR_ID);

🐜 ВАЖНО:
Учитывайте также и то, что регистр названия таблиц важен, если создавать их из терминала СУБД.
В запросе на изменение таблицы вписывайте название второй таблицы в том регистре, в каком оно 
находится (у нас это нижний регистр). Иначе запрос вызовет в СУБД ошибку и не будет выполнен.

Пример:

▷ Пытаемся связать наши таблицы внешним ключом:

mysql> ALTER TABLE employees ADD FOREIGN KEY(CAR_ID) REFERENCES CARS(CAR_ID);

^- И при этом в нашем запросе на изменение таблицы 
«employees» название второй таблицы «cars» указано 
в верхнем регистре (CARS), а не в нижнем (cars).

▷ Ну и соответственно мы получаем такую вот ошибку:

ERROR 1215 (HY000): Cannot add foreign key constraint
---------------------------------------------------------------------------------------------------------

◼ Внешний ключ создан, а теперь 
заполним таблицы тестовыми данными:

INSERT cars(YEAR, MODEL, MARK) 
VALUES
('1989', 'GAZ', '2400'),
('2012', 'BMW', '740d xDrive'),
('1993', 'daimler benz', 'w124'),
('2020', 'Honda', 'Civic');

◼ Посмотрим как это выглядит:

mysql> select * from cars;

▣ Вывод ТБ в консоль:
+--------+------+--------------+-------------+
| CAR_ID | YEAR | MODEL        | MARK        |
+--------+------+--------------+-------------+
|      1 | 1989 | GAZ          | 2400        |
|      2 | 2012 | BMW          | 740d xDrive |
|      3 | 1993 | daimler benz | w124        |
|      4 | 2020 | Honda        | Civic       |
+--------+------+--------------+-------------+

◼ Добавим сотрудников компании:

INSERT employees(NAME, SURNAME, CAR_ID)
VALUES('Oleg', 'Petrov', '1');

^- В этом запросе на добавление данных сотрудника в нашу ТБ 
мы намеренно указали только три поля (NAME, SURNAME, CAR_ID),
а не все семь полей куда ещё можно добавить данные сотрудника.

INSERT employees(NAME, SURNAME, PATRONYMIC, CITY, ADDRESS, NUMBER, CAR_ID) 
VALUES('Ivan', 'Ivanov', 'Ivanovi4', 'Moscow', 'Mira h.1 fl.3', '+79008001010', '3'),
('Oleg', 'Morkovkin', 'Yrjevich', 'Mytishchi', 'pr. krasnoy armii 212/3', '+79001008080', '2');

^- А в этом запросе на добавление данных о сотрудниках в нашу ТБ 
мы уже указали все семь основных полей присутствующих в нашей ТБ
(NAME, SURNAME, PATRONYMIC, CITY, ADDRESS, NUMBER, CAR_ID), а ID
добавляет AUTO_INCREMENT.
---------------------------------------------------------------------------------------------------------

🐜 ВАЖНО:
При попытке добавить пользователя с уже занятой 
машиной, мы получим ошибку (это есть дубликат).

Пример:

▷ Пытаемся добавить пользователя 
с уже занятым ранее ID машины: 

INSERT employees(NAME, SURNAME, CAR_ID) VALUES ('TEST', 'TESTOV', '2');

▷ И получаем вот такую ошибку:

ERROR 1062 (23000): Duplicate entry '2' for key 'CAR_ID'

^- Подобным запросом мы проверили, что наш 
столбец - CAR_ID (в таблице - employees) 
действительно был наделён - UNIQUE KEY.
---------------------------------------------------------------------------------------------------------

◼ А теперь посмотрим на нашу таблицу:

mysql> select * from employees;

▣ Вывод ТБ в консоль:
+----+------+-----------+------------+-----------+-------------------------+--------------+--------+
| ID | NAME | SURNAME   | PATRONYMIC | CITY      | ADDRESS                 | NUMBER       | CAR_ID |
+----+------+-----------+------------+-----------+-------------------------+--------------+--------+
|  1 | Oleg | Petrov    | NULL       | NULL      | NULL                    | NULL         |      1 |
|  2 | Ivan | Ivanov    | Ivanovi4   | Moscow    | Mira h.1 fl.3           | +79008001010 |      3 |
|  3 | Oleg | Morkovkin | Yrjevich   | Mytishchi | pr. krasnoy armii 212/3 | +79001008080 |      2 |
+----+------+-----------+------------+-----------+-------------------------+--------------+--------+

^- И как мы видим в нашей ТБ у первого добавленного нами сотрудника 
поля [PATRONYMIC, CITY, ADDRESS, NUMBER] содержат лишь NULL (пусто).                    
---------------------------------------------------------------------------------------------------------

🐜 ВАЖНО:
В консоли MySQL при запросах (SELECT * FROM table;) на просмотр длинных 
или высоких таблиц могут возникнуть дефекты, как некорректные отображения 
выводимых таблиц, если в свойствах окна не выставить ( + / - ) подобные вот 
этим параметры:

1. Клик ПКМ по верхнему краю рамки окна консоли MySQL

2. На выпадающем списке выбрать «Свойства» (клик ЛКМ)

3. В открывшемся окне перейти на вкладку «Расположение»

4. В настройках, где задаётся - [Размер окна] выставить 
следующие параметры:

□ Ширина: 109

□ Высота: 27

^- [Размер буфера экрана] - настраивать необязательно, 
т. к. там уже имеется автоподстройка под размер экрана
---------------------------------------------------------------------------------------------------------

□ А теперь мы составим простенький select-запрос для того, 
чтобы посмотреть связь между двумя нашими таблицами. Выведем 
имя и фамилию водителя, а также его марку машины сразу из двух 
наших таблиц.

◼ Пример такого запроса:

SELECT employees.NAME, employees.SURNAME, cars.MODEL 
FROM employees, cars WHERE employees.car_id = cars.car_id;

^- В этом запросе у нас после оператора SELECT (выбрать) указаны
полные имена столбцов¹ из обеих наших таблиц (employees | cars).
Далее, после оператора FROM (откуда) у нас идут имена наших 
таблиц (employees, cars), а после оператора WHERE (где) имеется
указание на то, что столбцы с именами как - CAR_ID обоих наших 
таблиц между собой равны: [employees.car_id = cars.car_id].

▣ Вывод ТБ в консоль:
+------+-----------+--------------+
| NAME | SURNAME   | MODEL        |
+------+-----------+--------------+
| Oleg | Petrov    | GAZ          |
| Ivan | Ivanov    | daimler benz |
| Oleg | Morkovkin | BMW          |
+------+-----------+--------------+

^- И это уже пример такого понятия в SQL, как 
«соединение таблиц» (или объединение таблиц).
---------------------------------------------------------------------------------------------------------  

1. [*** Полные имена столбцов ***]

В SQL, вы можете указать имя таблицы 
перед именем столбца, разделяя их точкой.

▷ Следующие утверждения эквивалентны:

SELECT City FROM customers;

SELECT customers.City FROM customers;

Термин вышеупомянутого синтаксиса 
называется «ПОЛНЫМ ИМЕНЕМ» этого 
столбца.

Такая форма написания будет особенно полезна при работе 
со множеством таблиц, которые могут иметь одинаковые 
названия столбцов. (←_←)
---------------------------------------------------------------------------------------------------------

На данном примере мы разобрались, как строить связь «ОДИН-К-ОДНОМУ». 
Но из-за такой связи достаточно тяжело становится добавлять людей без 
машины, так как это вызовет ошибку.

И далее мы продолжим на практике разбирать другой тип связи — «ОДИН-КО-МНОГИМ».
---------------------------------------------------------------------------------------------------------

[*** Один ко многим ***]

Связь «ОДИН-КО-МНОГИМ» в реляционных базах данных реализуется тогда, 
когда объекту А может принадлежать или же соответствовать несколько 
объектов Б, но объекту Б может соответствовать только один объект А.

И приведём классический пример для лучшего понимания 
вышеобозначенного определения связи «ОДИН-КО-МНОГИМ»:

▷ У одного клиента может быть несколько телефонных номеров.

▷ Реализуем связь «ОДИН-КО-МНОГИМ» на практике.
---------------------------------------------------------------------------------------------------------

▶ Создаем БД и выбираем 
её в качестве основной:

mysql> create database onetomany;

mysql> use onetomany;

▶ Создадим первую таблицу, в данном 
случае это карточка нашего клиента:

CREATE TABLE client(ID INT AUTO_INCREMENT PRIMARY KEY, FIO varchar(255) NOT NULL);

▶ Создадим вторую таблицу и 
это будет сам наш справочник:

CREATE TABLE phone_num(
    ID INT AUTO_INCREMENT PRIMARY KEY, 
    NUMBER VARCHAR(13) NOT NULL, 
    USER_ID INT NOT NULL
);

▶ Теперь же мы создадим внешний ключ:

ALTER TABLE phone_num ADD FOREIGN KEY(USER_ID) REFERENCES client(ID);

🐜 ВАЖНО:
И как вы можете видеть мы уже не стали поле USER_ID 
в таблице phone_num делать уникальным (UNIQUE), т. к.
у одного клиента (USER_ID) может быть несколько тел.
номеров (NUMBER). И таким образом в поле - USER_ID 
могут и будут появляться дубли, а свойство UNIQUE
дубли в каком-либо поле принимает за ошибку (1062).

▷ Пример подобной ошибки при попытке задать 
полю USER_ID свойство UNIQUE, когда обе наши 
таблицы уже были заполнены данными о клиентах 
и их телефонах:

ALTER TABLE phone_num MODIFY COLUMN USER_ID INT NOT NULL UNIQUE;

ERROR 1062 (23000): Duplicate entry '1' for key 'USER_ID'
---------------------------------------------------------------------------------------------------------

▶ Далее, заполним все наши 
таблицы тестовыми данными:

INSERT client(FIO) VALUES 
('Ivanov Ivan Ivanovich'),
('Petrov Petr Petrovich'),
('Testerov Tester Testerovich'),
('Olgerd');

INSERT phone_num(NUMBER, USER_ID) 
VALUES
('89018001010', '1'), 
('89028002020', '1'),
('89038003030', '1');

INSERT phone_num(NUMBER, USER_ID) 
VALUES 
('89049004040', '2'), 
('89059005050', '2');

INSERT phone_num(NUMBER, USER_ID) 
VALUES('89069106060', '3');

▶ Посмотрим на итоговые 
данные в наших таблицах:

mysql> select * from client;

▣ Вывод ТБ в консоль:
+----+-----------------------------+
| ID | FIO                         |
+----+-----------------------------+
|  1 | Ivanov Ivan Ivanovich       |
|  2 | Petrov Petr Petrovich       |
|  3 | Testerov Tester Testerovich |
|  4 | Olgerd                      |
+----+-----------------------------+

mysql> select * from phone_num;

▣ Вывод ТБ в консоль:
+----+-------------+---------+
| ID | NUMBER      | USER_ID |
+----+-------------+---------+
|  1 | 89018001010 |       1 |
|  2 | 89028002020 |       1 |
|  3 | 89038003030 |       1 |
|  4 | 89049004040 |       2 |
|  5 | 89059005050 |       2 |
|  6 | 89069106060 |       3 |
+----+-------------+---------+
---------------------------------------------------------------------------------------------------------

▶ Ну и в конце с помощью уже знакомого 
нам select-запроса посмотрим на весь 
наш справочник целиком: 

SELECT NUMBER as 'Номер телефона', FIO as 'ФИО' 
FROM phone_num, client 
WHERE phone_num.USER_ID = client.ID;

^- И, как мы видим, в этом нашем запросе не были использованы «полные имена столбцов». 
Т. к. указанные нами после оператора SELECT столбцы присутствуют только в своих таблицах.
Столбец FIO есть только в таблице client, а столбец NUMBER есть только в таблице phone_num.
И, соответственно, СУБД MySQL это всё отлично понимает. Но вот если бы были в наших таблицах
двух столбцы с одинаковыми именами, то нужно бы было в этом случае прописывать полные имена
для наших столбцов. (←_←)

▣ Вывод ТБ в консоль:
+----------------+-----------------------------+
| Номер телефона | ФИО                         |
+----------------+-----------------------------+
| 89018001010    | Ivanov Ivan Ivanovich       |
| 89028002020    | Ivanov Ivan Ivanovich       |
| 89038003030    | Ivanov Ivan Ivanovich       |
| 89049004040    | Petrov Petr Petrovich       |
| 89059005050    | Petrov Petr Petrovich       |
| 89069106060    | Testerov Tester Testerovich |
+----------------+-----------------------------+

^- Данная конструкция - [NUMBER as 'Номер телефона'] 
чисто визуальная и нужна для улучшения восприятия 
информации пользователем.
---------------------------------------------------------------------------------------------------------

[*** Многие ко многим ***]

Связь «МНОГИЕ-КО-МНОГИМ» - реализуется в том случае, когда нескольким объектам из таблицы А 
может соответствовать несколько объектов из таблицы Б, и в тоже время, нескольким объектам 
из таблицы Б соответствует несколько объектов из таблицы А и организовывается посредством 
связывающей таблицы.

Как же нам организовать связь «МНОГИЕ-КО-МНОГИМ» в БД?

Связь «МНОГИЕ-КО-МНОГИМ» создается с помощью трех таблиц. 
Две таблицы – “источника” и одна соединительная таблица. 
Первичный ключ соединительной таблицы A_Б – составной¹. 
Она состоит из двух полей, двух внешних ключей, которые 
ссылаются на первичные ключи таблиц A и Б. (←_←)

1. Если первичный ключ состоит из единственного атрибута, 
его называют простым ключом. Если первичный ключ состоит 
из двух и более атрибутов, его называют составным ключом.

Как же нам создать связь «МНОГИЕ-КО-МНОГИМ»?

Чтобы представить связь «МНОГИЕ-КО-МНОГИМ», нужно создать третью (связующую) 
таблицу, в которой она разбивается на две связи «ОДИН-КО-МНОГИМ» (!). Первичные 
ключи двух таблиц вставляются в третью таблицу. В результате в третьей таблице 
сохраняются все экземпляры связи. (←_←)

Простой пример:

◇ Одна книга могла быть написана несколькими 
авторами. Автор мог написать несколько книг.

◇ Достаточно немногословное описание, но станет полностью 
понятно, когда мы реализуем связь «МНОГИЕ-КО-МНОГИМ» на 
практике. Мы создадим свой маленький книжный магазин.
---------------------------------------------------------------------------------------------------------

◆ Снова создаём БД, 
и делаем её активной:

mysql> create database manytomany;

mysql> use manytomany;

◆ Создаем таблицу с книгами 
и таблицу с авторами:

CREATE TABLE books(
    id_book INT AUTO_INCREMENT PRIMARY KEY, 
    title varchar(255) NOT NULL, 
    price float NOT NULL, 
    count int default 0); 

^- Если count (количество) в запросе не будет указано, 
то по умолчанию (default) количество будет равно нулю.

CREATE TABLE author(
    id_author INT AUTO_INCREMENT PRIMARY KEY, 
    fio varchar(255) NOT NULL, 
    address varchar(255), 
    phone varchar(13),
    city varchar(20), 
    country varchar(20), 
    borndate date NOT NULL, 
    deathdate date);

◆ Создаём результирующую таблицу:

CREATE TABLE result_table(
    author_id int not null, 
    book_id int not null, 
    PRIMARY KEY(author_id, book_id)
);

^- Для нашей связующей таблицы мы формируем составной ключ.
Выглядит составной ключ как первичный ключ, в котором указаны 
сразу два поля нашей ТБ (author_id, book_id), а не одно поле.
По сути, как мы уже знаем, первичный ключ - это просто набор
неких ограничений для полей таблицы. Вот и всё. (←_←)

◇ Хотелось бы сразу заметить, что первичным ключом 
в результирующей таблице являются оба поля. Так как 
один и тот же автор не может написать две одинаковые 
книги. (←_←)

◆ А теперь мы с помощью двух внешних ключей создадим взаимосвязь 
между авторами (ТБ author) и книгами (ТБ books) через нашу 3-ю 
связующую таблицу (result_table):

ALTER TABLE result_table ADD FOREIGN KEY(book_id) REFERENCES books(id_book);

ALTER TABLE result_table ADD FOREIGN KEY(author_id) REFERENCES author(id_author);

^- И здесь мы накладываем на все поля - result_table ещё и внешние ключи 
для их связи с основными полями (id) двух наших таблиц (books & author).
При этом не забываем, что все поля result_table также являются частями
её составного ключа (первичного). Следовательно, ограничений на нашу ТБ
result_table становится ещё больше. (←_←)

◆ Ну а теперь заполним нашу 
ТБ books тестовыми данными:

INSERT INTO books(title, price, count) 
VALUES('Сказ о бывалом', 12.25, 6);

◇ И мы получаем такую вот ошибку:

ERROR 1366 (HY000): Incorrect string value: '\xD0\xA1\xD0\xBA\xD0\xB0...' for column 'title' at row 1

◇ Хмм, видимо наша таблица не поддерживает UTF-8 кодировку, но это быстро поправимо.

🐜 ВАЖНО:
Как же решить проблему с поддержкой кодировки?
Вызовем команду изменения таблицы ALTER TABLE 
и выполним перевод всех текстовых значений 
в UTF-8 (CONVERT TO CHARACTER SET utf8).

◇ И вот пример как это сделать:

ALTER TABLE books CONVERT TO CHARACTER SET utf8;
---------------------------------------------------------------------------------------------------------

◇ И после преобразования всех символов 
в нашей таблице books в UTF-8 =>

◆ Мы теперь уже наверняка заполним 
нашу таблицу тестовыми данными:

INSERT INTO books(title, price, count) 
VALUES('Сказ о бывалом', 12.25, 6);

INSERT INTO books(title, price, count) 
VALUES('Самая важная книга', 25, 2);

INSERT INTO books(title, price, count) 
VALUES 
('Как помыться в московском метро??', 10, 6),
('Сборник случайных рассказов ТОМ 1', 15, 5),
('Сборник случайных рассказов ТОМ 2', 15.5, 6),
('Сборник случайных рассказов ТОМ 3', 16, 2);

INSERT INTO books(title, price, count) 
VALUES
('Пустая книга', 11.5, 0),
('Явно дорогая книга', 250, 2),
('Явно дешевая книга', 0.56, 15),
('Явно неявная книга', 10, 10);

INSERT INTO books(title, price, count) 
VALUES('Страшная книга', 12.3, 1);

INSERT INTO books(title, price, count) 
VALUES('Весёлая книга', 14, 1);

^- Для быстрого заполнения таблицы (ТБ) 
можно сразу отправить ВСЕ четыре запроса 
на её заполнение. И в СУБД MySQL это всё
будет работать. (←_←)
---------------------------------------------------------------------------------------------------------

◆ Посмотрим на результат:

SELECT 
id_book AS 'Нумерация',
title AS 'Название книги', 
price AS 'Стоимость', 
count AS 'Количество' 
FROM books;

▣ Вывод ТБ в консоль:
+-----------+-----------------------------------+-----------+------------+
| Нумерация | Название книги                    | Стоимость | Количество |
+-----------+-----------------------------------+-----------+------------+
|         1 | Сказ о бывалом                    |     12.25 |          6 |
|         2 | Самая важная книга                |        25 |          2 |
|         3 | Как помыться в московском метро?? |        10 |          6 |
|         4 | Сборник случайных рассказов ТОМ 1 |        15 |          5 |
|         5 | Сборник случайных рассказов ТОМ 2 |      15.5 |          6 |
|         6 | Сборник случайных рассказов ТОМ 3 |        16 |          2 |
|         7 | Пустая книга                      |      11.5 |          0 |
|         8 | Явно дорогая книга                |       250 |          2 |
|         9 | Явно дешевая книга                |      0.56 |         15 |
|        10 | Явно неявная книга                |        10 |         10 |
|        11 | Страшная книга                    |      12.3 |          1 |
|        12 | Весёлая книга                     |        14 |          1 |
+-----------+-----------------------------------+-----------+------------+

^- При заполнении нашей таблицы данными произошёл некий казус. 
Запись об одной из книг в нашей таблице (ТБ books) задвоилась 
(по всей видимости, первый наш запрос был отправлен дважды).

🐜 ВАЖНО:
Далее, у нас была попытка удаления 
ошибочной записи из нашей таблицы:

DELETE FROM books WHERE id_book = 1;

Казалось бы, вот оно, решение нашей проблемы. 
Но, как затем оказалось, здесь не всё так просто. 
Т. к. у главного столбца id_book (PK) таблицы books
в свойствах был прописан авто-инкремент (AUTO_INCREMENT).
И, соответственно, после удаления самой первой верхней записи
из нашей таблицы правильная индексация всех идентификаторов 
нашей таблицы была грубо нарушена. Первая запись в таблице
по столбцу id_book теперь была пронумерована как 2-ая (её
идентификатор), а первой записи с id_book=1 более не было.
Вот он, подводный камень из-за использования авто-инкремента.
И проблема была решена с помощью инструкции - TRUNCATE TABLE:

TRUNCATE TABLE books;¹

^- Этой командой мы удалили все записи из нашей ТБ books (но не саму ТБ), 
а заодно мы сбросили всю индексацию строк нашей таблицы, произведенную 
ранее авто-инкрементированием столбца id_book (свойство AUTO_INCREMENT).
Данная команда работает не только в СУБД MySQL. (←_←)

После удаления всех некорректных записей из ТБ books мы взяли и 
снова заполнили эту таблицу всеми подготовленными ранее данными 
о нашем книжном магазине. Вот так нам удалось исправить ошибку.

1. TRUNCATE TABLE books; - Удаляет все строки из таблицы. И при этом 
она сбрасывает (обнуляет) авто-инкремент, а DELETE этого не делает.
---------------------------------------------------------------------------------------------------------

◇ Далее, нам нужно заполнить 
тестовыми данными ТБ author. 

◆ Также переводим таблицу 
в режим работы с UTF-8:

ALTER TABLE author CONVERT TO CHARACTER SET utf8;

◆ Добавляем теперь тестовые 
данные для авторов книг:

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES
('Иванов Иван Иванович', 'ул. Кого-то-там, д. 15, кв. 3', '+79018001010', 'Санкт-Петербург', 'Россия', '1985-12-23', NULL);

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES 
('Петров Петр Петрович', 'проспект Важного Маршала, д. 5/2а, кв. 22', NULL, 'Горький', 'СССР', '1955-10-23', '2015-03-15');

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES 
('Сидоров Сидр Сидорович', 'ул. Советская, д. 5, кв. 1', NULL, 'Чкалов', 'СССР', '1922-02-01', '1991-03-05'); 

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES 
('Коньков Олег Игоревич', 'Андреевский спуск, дом 3, кв. 5', '+79018200010', 'Киев', 'Украина', '1989-10-28', NULL);

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES 
('Коньков Олег Игоревич', 'Андреевский спуск, дом 3, кв. 5', '+79018200010', 'Киев', 'Украина', '1989-10-28', NULL);

◆ Посмотрим на результат:

SELECT id_author as 'ID', fio as 'FIO', city, country FROM author;

▣ Вывод ТБ в консоль:
+----+------------------------+-----------------+---------+
| ID | FIO                    | city            | country |
+----+------------------------+-----------------+---------+
|  1 | Иванов Иван Иванович   | Санкт-Петербург | Россия  |
|  2 | Петров Петр Петрович   | Горький         | СССР    |
|  3 | Сидоров Сидр Сидорович | Чкалов          | СССР    |
|  4 | Коньков Олег Игоревич  | Киев            | Украина |
|  5 | Коньков Олег Игоревич  | Киев            | Украина |
+----+------------------------+-----------------+---------+

^- Упс! Видимо при добавлении пользователей у нас получилась 
ошибка, ну ничего, такое бывает — поменяем пользователя с 
id = 5 с помощью команды update. (←_←)

◆ Обновляем нашего 
злополучного автора: 

UPDATE author SET
fio = 'Тестеровский Тестер Тестерович',
address = 'ул. Железнодорожная, д. 33, кв. 3', 
city = 'Ивано-Франковск', 
phone = '+79991117733', 
borndate = '1982-08-13'
WHERE id_author = 5;

🐜 ВАЖНО:
Выше нами обозначен ещё один способ 
для решения проблемы дублирования
какой-либо сущности в таблице.
---------------------------------------------------------------------------------------------------------

◆ Добавим ещё одного автора:

INSERT author(fio, address, phone, city, country, borndate, deathdate) 
VALUES 
('Конь Вадим Вадимович', 'ул. Монтажников, дом 16, кв. 104', '+79117230518', 'Оренбург', 'Россия', '1999-11-21', NULL);

◆ И теперь взглянем на то, 
что у нас в итоге получилось:

SELECT id_author as 'ID', fio as 'FIO', city, country FROM author;

▣ Вывод ТБ в консоль:
+----+--------------------------------+-----------------+---------+
| ID | FIO                            | city            | country |
+----+--------------------------------+-----------------+---------+
|  1 | Иванов Иван Иванович           | Санкт-Петербург | Россия  |
|  2 | Петров Петр Петрович           | Горький         | СССР    |
|  3 | Сидоров Сидр Сидорович         | Чкалов          | СССР    |
|  4 | Коньков Олег Игоревич          | Киев            | Украина |
|  5 | Тестеровский Тестер Тестерович | Ивано-Франковск | Украина |
|  6 | Конь Вадим Вадимович           | Оренбург        | Россия  |
+----+--------------------------------+-----------------+---------+
---------------------------------------------------------------------------------------------------------

◆ А теперь создадим взаимосвязь между авторами (ТБ author) и книгами (ТБ books), 
добавив id сущностей из обеих таблиц в нашу 3-ю связующую таблицу (result_table). 
И тем самым мы свяжем наши три таблицы общими данными:

INSERT result_table(book_id, author_id) 
VALUES
(1, 1), (2, 2), (2, 3), (3, 2), (4, 5), (5, 5), (6, 5), (11, 6);

INSERT INTO result_table(book_id, author_id) 
VALUES
(7, 4), (8, 4), (9, 4), (10, 4), (10, 5), (8, 2), (9, 2), (10, 2), (12, 2);      

◇ К сожалению результирующая таблица выглядит не очень понятно, 
но простыми запросами мы можем выяснить, кто автор какой книги, 
или вычислить общую стоимость книг на складе.

◆ Вот как выглядит наша результирующая 
таблица (ТБ result_table) сейчас:

SELECT * FROM result_table ORDER BY book_id;

▣ Вывод ТБ в консоль:
+-----------+---------+
| author_id | book_id |
+-----------+---------+
|         1 |       1 |
|         2 |       2 |
|         3 |       2 |
|         2 |       3 |
|         5 |       4 |
|         5 |       5 |
|         5 |       6 |
|         4 |       7 |
|         2 |       8 |
|         4 |       8 |
|         2 |       9 |
|         4 |       9 |
|         2 |      10 |
|         4 |      10 |
|         5 |      10 |
|         6 |      11 |
|         2 |      12 |
+-----------+---------+
---------------------------------------------------------------------------------------------------------

◆ Пример кода для того, чтобы понять, кто написал какую 
книгу и кто с кем был в соавторстве (используем короткие 
синонимы - алиасы - для имен таблиц, чтобы было понятно в 
какой таблице находится то или иное поле):

SELECT a.fio, b.title FROM author a, books b, result_table r 
WHERE r.author_id = a.id_author AND r.book_id = b.id_book 
ORDER BY b.title;

▣ Вывод ТБ в консоль:
+--------------------------------+-----------------------------------+
| fio                            | title                             |
+--------------------------------+-----------------------------------+
| Петров Петр Петрович           | Весёлая книга                     |
| Петров Петр Петрович           | Как помыться в московском метро?? |
| Коньков Олег Игоревич          | Пустая книга                      |
| Петров Петр Петрович           | Самая важная книга                |
| Сидоров Сидр Сидорович         | Самая важная книга                |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 1 |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 2 |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 3 |
| Иванов Иван Иванович           | Сказ о бывалом                    |
| Конь Вадим Вадимович           | Страшная книга                    |
| Петров Петр Петрович           | Явно дешевая книга                |
| Коньков Олег Игоревич          | Явно дешевая книга                |
| Петров Петр Петрович           | Явно дорогая книга                |
| Коньков Олег Игоревич          | Явно дорогая книга                |
| Петров Петр Петрович           | Явно неявная книга                |
| Коньков Олег Игоревич          | Явно неявная книга                |
| Тестеровский Тестер Тестерович | Явно неявная книга                |
+--------------------------------+-----------------------------------+

◇ Расшифровка всех сокращений:

На SELECT:

author.fio = a.fio (сокр.)
^- полное имя столбца fio в таблице author

books.title = b.title (сокр.)
^- полное имя столбца title в таблице title

На FROM:

author a
^- таблица author как - a

books b
^- таблица books как - b

result_table r
^- таблица result_table как - r

На WHERE:

r.author_id = a.id_author (сокр.)

^- result_table.author_id = author.id_author 

r.book_id = b.id_book (сокр.)

^- result_table.book_id = books.id_book 

На ORDER BY¹⁽²⁾:

b.title (сокр.)

^- books.title

1. ORDER BY - Отсортировать все записи 
в каком-либо поле по возрастанию (можно 
указать несколько полей через запятую).

2. По умолчанию все записи сортируются 
по возрастанию, чтобы отсортировать по 
убыванию нужно проставить - DESC.

И здесь синтаксис будет такой:

SELECT * FROM имя_таблицы WHERE условие ORDER BY поле DESC
---------------------------------------------------------------------------------------------------------

◆ Этот же запрос безо всяких сокращений:

SELECT author.fio as 'FIO', books.title 
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
ORDER BY books.title;

▣ Вывод ТБ в консоль:
+--------------------------------+-----------------------------------+
| FIO                            | title                             |
+--------------------------------+-----------------------------------+
| Петров Петр Петрович           | Весёлая книга                     |
| Петров Петр Петрович           | Как помыться в московском метро?? |
| Коньков Олег Игоревич          | Пустая книга                      |
| Петров Петр Петрович           | Самая важная книга                |
| Сидоров Сидр Сидорович         | Самая важная книга                |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 1 |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 2 |
| Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 3 |
| Иванов Иван Иванович           | Сказ о бывалом                    |
| Конь Вадим Вадимович           | Страшная книга                    |
| Петров Петр Петрович           | Явно дешевая книга                |
| Коньков Олег Игоревич          | Явно дешевая книга                |
| Петров Петр Петрович           | Явно дорогая книга                |
| Коньков Олег Игоревич          | Явно дорогая книга                |
| Петров Петр Петрович           | Явно неявная книга                |
| Коньков Олег Игоревич          | Явно неявная книга                |
| Тестеровский Тестер Тестерович | Явно неявная книга                |
+--------------------------------+-----------------------------------+
---------------------------------------------------------------------------------------------------------

◆ Сформируем запрос, чтобы посмотреть, как хранит 
свои данные 3-я связующая таблица result_table:

SELECT result_table.author_id, result_table.book_id, author.fio as 'FIO', books.title  
FROM author, books, result_table WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
ORDER BY books.id_book, author.id_author;

▣ Вывод ТБ в консоль:
+-----------+---------+--------------------------------+-----------------------------------+
| author_id | book_id | FIO                            | title                             |
+-----------+---------+--------------------------------+-----------------------------------+
|         1 |       1 | Иванов Иван Иванович           | Сказ о бывалом                    |
|         2 |       2 | Петров Петр Петрович           | Самая важная книга                |
|         3 |       2 | Сидоров Сидр Сидорович         | Самая важная книга                |
|         2 |       3 | Петров Петр Петрович           | Как помыться в московском метро?? |
|         5 |       4 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 1 |
|         5 |       5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 2 |
|         5 |       6 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 3 |
|         4 |       7 | Коньков Олег Игоревич          | Пустая книга                      |
|         2 |       8 | Петров Петр Петрович           | Явно дорогая книга                |
|         4 |       8 | Коньков Олег Игоревич          | Явно дорогая книга                |
|         2 |       9 | Петров Петр Петрович           | Явно дешевая книга                |
|         4 |       9 | Коньков Олег Игоревич          | Явно дешевая книга                |
|         2 |      10 | Петров Петр Петрович           | Явно неявная книга                |
|         4 |      10 | Коньков Олег Игоревич          | Явно неявная книга                |
|         5 |      10 | Тестеровский Тестер Тестерович | Явно неявная книга                |
|         6 |      11 | Конь Вадим Вадимович           | Страшная книга                    |
|         2 |      12 | Петров Петр Петрович           | Весёлая книга                     |
+-----------+---------+--------------------------------+-----------------------------------+

^- И по этому запросу видно, что result_table хранит свои 
данные как комбинации чисел. К примеру, вот так: ['6-11'].

🐜 ВАЖНО:
И добавлять в result_table следует именно пару чисел (связку / комбинацию чисел). 
И оба этих числа должны наличествовать в основных столбцах таблиц author и books. 
Иначе сработают все ограничения, установленные нами при создании result_table.

Примеры:

◆ Мы пытаемся добавить в ТБ result_table пару чисел. Первое число это id сущности из таблицы books 
(и при этом в ТБ books пока что нет id = 13, а есть только id = 12). Второе число это id сущности 
из таблицы author (в ТБ author есть id = 6):

INSERT INTO result_table(book_id, author_id) VALUES(13, 6);

◆ И мы получаем ошибку, связанную 
с ограничением по внешнему ключу 
столбца book_id:

ERROR 1452 (23000): 
Cannot add or update a child row: a foreign key constraint fails (`manytomany`.`result_table`, 
CONSTRAINT `result_table_ibfk_1` FOREIGN KEY (`book_id`) REFERENCES `books` (`id_book`))
=========================================================================================================

◆ Мы пытаемся добавить в таблицу result_table 
число, но только в первый её столбец (book_id), 
а добавление числа во второй её столбец 
(author_id) мы специально избегаем:

INSERT INTO result_table(book_id) VALUES(11);

◆ И мы получаем ошибку, т. к. поле author_id 
не может быть пустым (not null) и при этом поле 
author_id не имеет значения по умолчанию (default):

ERROR 1364 (HY000): Field 'author_id' doesn't have a default value
=========================================================================================================

◆ Мы пытаемся добавить в ТБ result_table идентификаторы 
(id) сущностей из таблиц books и author (и такого рода 
номера id в обеих наших таблицах уже наличествуют):

INSERT INTO result_table(book_id, author_id) VALUES(11, 6);

◆ И мы получаем ошибку, связанную с попыткой 
дублирования записи для первичного ключа 
таблицы result_table:

ERROR 1062 (23000): Duplicate entry '6-11' for key 'PRIMARY'

^- Т. е. ограничение на уникальность, которая есть у первичного ключа, действует на дубли тогда, 
когда совпадает именно комбинация чисел (уже существующая в таблице result_table). Числа в связке 
из двух чисел могут совпадать с существующими числами в ТБ result_table, но только по одному числу 
в их комбинации. А если совпадут сразу оба числа (в их комбинации), то будет ошибка (ограничение по 
PK). И нам не следует бояться, что в таблицу result_table попадёт не уникальная комбинация чисел, т. 
к. у таблицы имеется составной первичный ключ (CPK - composite primary key).
=========================================================================================================

◇ Существует ещё одна возможность вызвать 
ошибку ввода дубликата для первичного ключа.
К примеру, у нас в таблице result_table есть
автор, которому мы хотим сменить «авторство».
Т. к. была допущена ошибка, и автор не писал
определённую книгу, а ему определили, что
написал её именно он.    

◇ И нам нужно в ТБ result_table у записи, 
где author_id = 4 и book_id = 8 сменить 
ей book_id = 8 на book_id = 12.

◆ Пробуем сменить нашему автору 
книгу таким вот неполным запросом:

UPDATE result_table SET book_id = 12 WHERE author_id = 4;

◆ И мы получаем ошибку, связанную с попыткой 
дублирования записи для первичного ключа 
таблицы result_table:

ERROR 1062 (23000): Duplicate entry '4-12' for key 'PRIMARY'

^- А всё потому, что данному автору изначально было присвоено несколько книг. 
И в ТБ result_table есть несколько записей с author_id = 4. В этом случае также 
сработают все ограничения составного первичного ключа, относящиеся к уникальности 
записей в ТБ result_table.

◇ А вот и правильный update-запрос на смену нашему 
автору неправильно присвоенного ему авторства книги. 
На то авторство, которое является верным:

UPDATE result_table SET book_id = 12 WHERE author_id = 4 AND book_id = 8;
=========================================================================================================

◆ А также мы заодно протестируем возможность 
удаления неправильных или некорректных записей 
из нашей таблицы - [result_table]:

DELETE FROM result_table WHERE author_id = 2 AND book_id = 3;

DELETE FROM result_table WHERE author_id = 2 AND book_id = 8;

DELETE FROM result_table WHERE author_id = 2 AND book_id = 9;

DELETE FROM result_table WHERE author_id = 2 AND book_id = 10;

DELETE FROM result_table WHERE author_id = 2 AND book_id = 12;

^- Всё прошло УСПЕШНО!!! Все эти записи 
были из ТБ result_table с успехом удалены.
=========================================================================================================

◆ И заодно мы протестируем возможность изменения 
неправильных или некорректных записей из нашей 
результирующей таблицы - [result_table]:

UPDATE result_table SET book_id = 12 WHERE author_id = 4 AND book_id = 8;

^- Всё прошло УСПЕШНО!!! Данная запись в 
ТБ result_table была с успехом изменена.
=========================================================================================================

◆ Пишем запрос, чтобы найти 
книги уже не живых авторов:

SELECT author.fio as 'FIO', books.title 
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND deathdate IS NOT NULL;

▣ Вывод ТБ в консоль:
+------------------------+--------------------+
| FIO                    | title              |
+------------------------+--------------------+
| Петров Петр Петрович   | Самая важная книга |
| Сидоров Сидр Сидорович | Самая важная книга |
+------------------------+--------------------+
=========================================================================================================

◆ Узнаем какие книги 
написали авторы-петербуржцы:

SELECT author.fio as 'FIO', books.title 
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND author.city = 'Санкт-Петербург';

▣ Вывод ТБ в консоль:
+----------------------+----------------+
| FIO                  | title          |
+----------------------+----------------+
| Иванов Иван Иванович | Сказ о бывалом |
+----------------------+----------------+
=========================================================================================================

◆ Узнаем какие книги 
написали авторы-оренбуржцы:

SELECT author.fio as 'FIO', books.title 
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND author.city = 'Оренбург';

▣ Вывод ТБ в консоль:
+----------------------+----------------+
| FIO                  | title          |
+----------------------+----------------+
| Конь Вадим Вадимович | Страшная книга |
+----------------------+----------------+
=========================================================================================================

◆ Добавим в нашу базу 
ещё немного данных:

INSERT INTO result_table(book_id, author_id) 
VALUES(3, 5), (8, 5);
=========================================================================================================

◆ И найдём самую дорогую книгу:

SELECT author.fio as 'FIO', books.title, books.price 
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND price = (SELECT MAX(price) FROM books);

▣ Вывод ТБ в консоль:
+--------------------------------+--------------------+-------+
| FIO                            | title              | price |
+--------------------------------+--------------------+-------+
| Тестеровский Тестер Тестерович | Явно дорогая книга |   250 |
+--------------------------------+--------------------+-------+
=========================================================================================================

◆ А теперь найдём самую дешёвую книгу:

SELECT author.fio as 'FIO', books.title, books.price
FROM author, books, result_table 
WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND price = (SELECT MIN(price) FROM books);

▣ Вывод ТБ в консоль:
+-----------------------+--------------------+-------+
| FIO                   | title              | price |
+-----------------------+--------------------+-------+
| Коньков Олег Игоревич | Явно дешевая книга |  0.56 |
+-----------------------+--------------------+-------+
=========================================================================================================

◆ Последний наш select-запрос 
для демонстрации связи всех 
трёх наших таблиц:

SELECT result_table.author_id, author.fio as 'FIO', books.title, result_table.book_id  
FROM author, books, result_table WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
ORDER BY books.id_book, author.id_author;

▣ Вывод ТБ в консоль:
+-----------+--------------------------------+-----------------------------------+---------+
| author_id | FIO                            | title                             | book_id |
+-----------+--------------------------------+-----------------------------------+---------+
|         1 | Иванов Иван Иванович           | Сказ о бывалом                    |       1 |
|         2 | Петров Петр Петрович           | Самая важная книга                |       2 |
|         3 | Сидоров Сидр Сидорович         | Самая важная книга                |       2 |
|         5 | Тестеровский Тестер Тестерович | Как помыться в московском метро?? |       3 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 1 |       4 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 2 |       5 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 3 |       6 |
|         4 | Коньков Олег Игоревич          | Пустая книга                      |       7 |
|         5 | Тестеровский Тестер Тестерович | Явно дорогая книга                |       8 |
|         4 | Коньков Олег Игоревич          | Явно дешевая книга                |       9 |
|         4 | Коньков Олег Игоревич          | Явно неявная книга                |      10 |
|         5 | Тестеровский Тестер Тестерович | Явно неявная книга                |      10 |
|         6 | Конь Вадим Вадимович           | Страшная книга                    |      11 |
|         4 | Коньков Олег Игоревич          | Весёлая книга                     |      12 |
+-----------+--------------------------------+-----------------------------------+---------+
=========================================================================================================

◆ Как вывести все книги написанные 
только определённым автором:

SELECT result_table.author_id, author.fio as 'FIO', books.title, result_table.book_id  
FROM author, books, result_table WHERE result_table.author_id = author.id_author 
AND result_table.book_id = books.id_book 
AND id_author = 5;

▣ Вывод ТБ в консоль:
+-----------+--------------------------------+-----------------------------------+---------+
| author_id | FIO                            | title                             | book_id |
+-----------+--------------------------------+-----------------------------------+---------+
|         5 | Тестеровский Тестер Тестерович | Как помыться в московском метро?? |       3 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 1 |       4 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 2 |       5 |
|         5 | Тестеровский Тестер Тестерович | Сборник случайных рассказов ТОМ 3 |       6 |
|         5 | Тестеровский Тестер Тестерович | Явно дорогая книга                |       8 |
|         5 | Тестеровский Тестер Тестерович | Явно неявная книга                |      10 |
+-----------+--------------------------------+-----------------------------------+---------+
=========================================================================================================

[*** Схемы связей ***]

Обозначения:

● 1-table - Main table 
(Основная / Первая таблица)

● 2-table - Secondary table 
(Второстепенная / Вторая таблица)

● 3-table - Relationship table  
(Связующая таблица)

● PK - Primary Key (Первичный ключ)

● FK - Foreign Key (Внешний ключ)

● CPK - Composite Primary Key 
(Составной Первичный ключ)

● Остриё стрелки (=>) всегда указывает на внешний ключ (FK), 
а конец стрелки всегда отходит от первичного ключа (PK), тем 
самым демонстрируя отношения и связь между ключами (PK => FK).
Таблица, на которую направлена стрелка, будет всегда находится
в зависимом положении.

Схемы:

1. «ОДИН-КО-ОДНОМУ» схема:
+---------------------------------------+
| 1-table (FK + UNIQUE) <= 2-table (PK) |
+---------------------------------------+

2. «ОДИН-КО-МНОГИМ» схема:
+------------------------------+
| 1-table (PK) => 2-table (FK) |
+------------------------------+

3. «МНОГИЕ-КО-МНОГИМ» схема:
+-------------------------------------------------------------------+
| 1-table (PK) => 3-table [CPK = PK(⁺FK) + PK(⁺FK)] <= 2-table (PK) |
+-------------------------------------------------------------------+
=========================================================================================================

В данном модуле мы:

● Узнали, что такое базы данных, 
какие они бывают и для чего они 
обычно нужны.

● Поняли и разобрались в принципиальной 
разнице реляционных и нереляционных баз 
данных.

● Рассмотрели, как работают 
транзакции и для чего они нужны. 

● Поняли, что такое СУБД и для чего она нужна.

● Посмотрели на то, как представлены данные в 
нереляционных базах данных, и в чём преимущества 
различных моделей таких БД. Изучили, как работать 
с MongoDB и Redis. 

● Также изучили принцип работы реляционных БД и их модели данных. 
Поняв, что такое первичный и внешний ключ, посмотрели на три модели 
связей в базах данных. На практике изучили создание БД с различными 
связями.
=========================================================================================================


























































